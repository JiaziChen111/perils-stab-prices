function [gap_simu, pi_simu, gap_lag_simu_next, ...
    b_pi_simu_next, b_gap_simu_next, ...
    lambda1_simu, gamma_t_simu_next] = ...
    allocations_in_period_i_fast_ALA(model, gaintype, states, fspace, parpolicy,...
    benchparameters, b_gap_simu, mcparameters, R_simu, ALA, gamma_t_decr)

% allocations_in_period_i_fast_ALA computes the allocations for the simulations (Alternative learning algorithms)
% 
% Inputs:
% model: string indicating which model it is ('MMS', 'EHCOMM', 'EHDISCR', 'REDISCR', 'RECOMM', 'IMP1', 'IMP2')
% gaintype: string indicating the gain type 'decr' or 'const'
% states: a row vector containing the values for the states when entering the period
% fspace: functional space for collocation generated by CompEcon
% parpolicy: coefficients for the basis functions (this is obtained after solving the model)
% benchparameters: parameters for the model
% b_gap_simu: the value of b_gap_simu when entering the period (this is needed since it is not a state)
% mcparameters: parameters for the Montecarlo exercise
% R_simu: this is needed when doing OLS, otherwise it is set to 1
% ALA: string that identifies the alternative type of learning we are using
% gamma_t_decr: needed when ALA = 'decr'

%% GIVE INDIVIDUAL NAMES TO PARAMETERS
[alpha, betta, kappa, ~, gam, ~, sigma, ~, ...
    ~, ~, ~, ~, b_x_comm, ...
    b_pi_comm, c_x_comm, c_pi_comm, c_x_discr, ...
    c_pi_discr, ~, ~, ...
    ~,~, ~, ~, ...
    ~, ~, ~, ~, ~, ~, ~, ...
    ~, ~, imp] = translate_parameters(benchparameters);

%% GIVE INDIVIDUAL NAMES TO MC PARAMETERS
[~,~,~,~,~, ~, ~ , ~, shutdownlearning] = translate_mcparameters(mcparameters);

%% POLICY FUNCTION COEFFICIENTS
% Define the coefficients for interpolation of the variables
par0 = reshape(parpolicy,length(parpolicy)/2,2 );
parlambda1 =  par0(:,1);
pargap =      par0(:,2);


%% GIVE INDIVIDUAL NAMES TO STATES
gap_lag_simu = states(:,1);
b_pi_simu = states(:,2);
if strcmp(gaintype,'decr') 
    gamma_t_simu = states(:,3);
    costpushshock = states(:,4);
else
    if strcmp(ALA, 'decr')
        gamma_t_simu = gamma_t_decr;
    else
        gamma_t_simu = gam;
    end    
    costpushshock = states(:,3);
    
end




%% GENERATE ALLOCATIONS
switch model
    case 'MMS'
        if strcmp(ALA, 'OLS') % this puts a projection facility on x_t, b_pi and b_x 
            gap_simu = min(max(funeval(pargap,fspace, states), -0.8),0.8);
            pi_simu = (betta.*b_pi_simu + kappa).*gap_simu +...
                costpushshock;
            gap_lag_simu_next = gap_simu;
            b_pi_simu_next = max(b_pi_simu  + gap_lag_simu.*(pi_simu - ...
                gap_lag_simu.*b_pi_simu).*gamma_t_simu./R_simu, -0.01);
            b_gap_simu_next = max(b_gap_simu  + gamma_t_simu.*gap_lag_simu.*(gap_simu - ...
                gap_lag_simu.*b_gap_simu)./R_simu, -0.01);
        else
            gap_simu = funeval(pargap,fspace, states);
            pi_simu = (betta.*b_pi_simu + kappa).*gap_simu +...
                costpushshock;
            gap_lag_simu_next = gap_simu;
            b_pi_simu_next = b_pi_simu  + gap_lag_simu.*(pi_simu - ...
                gap_lag_simu.*b_pi_simu).*gamma_t_simu./R_simu;
            b_gap_simu_next = b_gap_simu  + gamma_t_simu.*gap_lag_simu.*(gap_simu - ...
                gap_lag_simu.*b_gap_simu)./R_simu;
        end
        
    case 'EHCOMM'
        gap_simu  = ((1+ (kappa*betta/(alpha + kappa^2)).*b_pi_simu ).^(-1)).*...
            ((alpha/(alpha +  kappa^2)).*gap_lag_simu ...
            -( kappa/(alpha +  kappa^2)).*costpushshock   );
        pi_simu  = (alpha*betta/(alpha + kappa^2)).*b_pi_simu .*gap_simu  + ...
            (alpha*kappa/(alpha +  kappa^2)).*gap_lag_simu  + ...
            ( alpha/(alpha +  kappa^2)).*costpushshock   ;
        gap_lag_simu_next = gap_simu ;
        b_pi_simu_next = b_pi_simu   + gap_lag_simu .*(pi_simu  - ...
            gap_lag_simu .*b_pi_simu ).*gamma_t_simu./R_simu ;
        b_gap_simu_next = b_gap_simu   + gamma_t_simu .*gap_lag_simu .*(gap_simu  - ...
            gap_lag_simu .*b_gap_simu )./R_simu;
        
    case 'EHDISCR'
        gap_simu = ( -( kappa/(alpha +  kappa^2)).*costpushshock   )./( 1 + (kappa.*betta./(alpha + kappa.^2)).*b_pi_simu ); 
        % gap_simu  = ( -( kappa/(alpha +  kappa^2)).*costpushshock   )./...
        %     (1- b_pi_simu ./sigma -...
        %     b_gap_simu );
        pi_simu = (betta.*b_pi_simu +  kappa).*gap_simu + costpushshock;
        % pi_simu( (betta + kappa./sigma).*b_pi_simu  +...
        %     kappa.*b_gap_simu ).*gap_simu  +  ...
        %     ( alpha/(alpha +  kappa^2)).*costpushshock   ;
        gap_lag_simu_next = gap_simu ;
        b_pi_simu_next = b_pi_simu   + gap_lag_simu .*(pi_simu  - ...
            gap_lag_simu .*b_pi_simu ).*gamma_t_simu./R_simu ;
        b_gap_simu_next = b_gap_simu   + gamma_t_simu .*gap_lag_simu .*(gap_simu  - ...
            gap_lag_simu .*b_gap_simu )./R_simu;
        
    case 'RECOMM'
        gap_simu  = b_x_comm.*gap_lag_simu  + ...
            c_x_comm.*costpushshock ;
        pi_simu  = b_pi_comm.*gap_lag_simu  + ...
            c_pi_comm.*costpushshock ;
        gap_lag_simu_next = gap_simu ;
        b_pi_simu_next = b_pi_comm;
        b_gap_simu_next =b_x_comm;
        
        
    case 'REDISCR'
        gap_simu  = c_x_discr.*costpushshock ;
        pi_simu  = c_pi_discr.*costpushshock ;
        gap_lag_simu_next = gap_simu ;
        b_pi_simu_next = 0;
        b_gap_simu_next =0;

    case 'IMP1'
        gap_simu = ( (imp./sigma).*b_pi_simu.*gap_lag_simu - (kappa./ (alpha + kappa.^2)).*costpushshock )./(1 + (kappa.*betta./ (alpha + kappa.^2)).*b_pi_simu);
        pi_simu = (betta.*b_pi_simu + kappa).*gap_simu +...
            costpushshock;
        gap_lag_simu_next = gap_simu;
        b_pi_simu_next = b_pi_simu  + gap_lag_simu.*(pi_simu - ...
            gap_lag_simu.*b_pi_simu).*gamma_t_simu;
        b_gap_simu_next = b_gap_simu  + gamma_t_simu.*gap_lag_simu.*(gap_simu - gap_lag_simu.*b_gap_simu);

    case 'IMP2'
        gap_simu = ( (imp./sigma).*b_gap_simu.*gap_lag_simu - (kappa./ (alpha + kappa.^2)).*costpushshock )./(1 + (kappa.*betta./ (alpha + kappa.^2)).*b_pi_simu);
        pi_simu = (betta.*b_pi_simu + kappa).*gap_simu +...
            costpushshock;
        gap_lag_simu_next = gap_simu;
        b_pi_simu_next = b_pi_simu  + gap_lag_simu.*(pi_simu - ...
            gap_lag_simu.*b_pi_simu).*gamma_t_simu;
        b_gap_simu_next = b_gap_simu  + gamma_t_simu.*gap_lag_simu.*(gap_simu - gap_lag_simu.*b_gap_simu);
        
end

if strcmp(gaintype,'decr')
    if shutdownlearning ==1
        gamma_t_simu_next = 0;
    else
        gamma_t_simu_next = gamma_t_simu ./(gamma_t_simu   + 1);
    end
else
    if strcmp(ALA, 'decr')
        gamma_t_simu_next = gamma_t_simu ./(gamma_t_simu   + 1);
    else
        gamma_t_simu_next = gam;
    end
end

lambda1_simu =  funeval(parlambda1,fspace, states);

end
